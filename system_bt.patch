diff --git a/bta/pan/bta_pan_act.c b/bta/pan/bta_pan_act.c
index 1995478..b1678d8 100644
--- a/bta/pan/bta_pan_act.c
+++ b/bta/pan/bta_pan_act.c
@@ -28,6 +28,8 @@
 
 #include "bta_api.h"
 #include "bta_sys.h"
+#include <cutils/log.h>
+
 #include "bt_common.h"
 #include "pan_api.h"
 #include "bta_pan_api.h"
@@ -176,6 +178,14 @@ static void bta_pan_data_buf_ind_cback(UINT16 handle, BD_ADDR src, BD_ADDR dst,
 
     if (sizeof(tBTA_PAN_DATA_PARAMS) > p_buf->offset) {
         /* offset smaller than data structure in front of actual data */
+        if (sizeof(BT_HDR) + sizeof(tBTA_PAN_DATA_PARAMS) + p_buf->len >
+            PAN_BUF_SIZE) {
+          android_errorWriteLog(0x534e4554, "63146237");
+          APPL_TRACE_ERROR("%s: received buffer length too large: %d", __func__,
+                           p_buf->len);
+          osi_free(p_buf);
+          return;
+        }
         p_new_buf = (BT_HDR *)osi_malloc(PAN_BUF_SIZE);
         memcpy((UINT8 *)(p_new_buf + 1) + sizeof(tBTA_PAN_DATA_PARAMS),
                (UINT8 *)(p_buf + 1) + p_buf->offset, p_buf->len);
diff --git a/btif/src/btif_sdp_server.cc b/btif/src/btif_sdp_server.cc
new file mode 100644
index 0000000..b84d694
--- /dev/null
+++ b/btif/src/btif_sdp_server.cc
@@ -0,0 +1,768 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2014 Samsung System LSI
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*******************************************************************************
+ *
+ *  Filename:      btif_sdp_server.cc
+ *  Description:   SDP server Bluetooth Interface to create and remove SDP
+ *                 records.
+ *                 To be used in combination with the RFCOMM/L2CAP(LE) sockets.
+ *
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_btif_sdp_server"
+
+#include <pthread.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <mutex>
+
+#include <hardware/bluetooth.h>
+#include <hardware/bt_sdp.h>
+
+#include "bta_sdp_api.h"
+#include "bta_sys.h"
+#include "btif_common.h"
+#include "btif_sock_util.h"
+#include "btif_util.h"
+#include "osi/include/allocator.h"
+#include "utl.h"
+
+// Protects the sdp_slots array from concurrent access.
+static std::recursive_mutex sdp_lock;
+
+/**
+ * The need for a state variable have been reduced to two states.
+ * The remaining state control is handled by program flow
+ */
+typedef enum {
+  SDP_RECORD_FREE = 0,
+  SDP_RECORD_ALLOCED,
+} sdp_state_t;
+
+typedef struct {
+  sdp_state_t state;
+  int sdp_handle;
+  bluetooth_sdp_record* record_data;
+} sdp_slot_t;
+
+#define MAX_SDP_SLOTS 128
+static sdp_slot_t sdp_slots[MAX_SDP_SLOTS];
+
+/*****************************************************************************
+ * LOCAL Functions
+ *****************************************************************************/
+static int add_maps_sdp(const bluetooth_sdp_mas_record* rec);
+static int add_mapc_sdp(const bluetooth_sdp_mns_record* rec);
+static int add_pbaps_sdp(const bluetooth_sdp_pse_record* rec);
+static int add_opps_sdp(const bluetooth_sdp_ops_record* rec);
+static int add_saps_sdp(const bluetooth_sdp_sap_record* rec);
+bt_status_t remove_sdp_record(int record_id);
+static int free_sdp_slot(int id);
+
+/******************************************************************************
+ * WARNING: Functions below are not called in BTU context.
+ * Introduced to make it possible to create SDP records from JAVA with both a
+ * RFCOMM channel and a L2CAP PSM.
+ * Overall architecture:
+ *  1) JAVA calls createRecord() which returns a pseudo ID which at a later
+ *     point will be linked to a specific SDP handle.
+ *  2) createRecord() requests the BTU task(thread) to call a callback in SDP
+ *     which creates the actual record, and updates the ID<->SDPHandle map
+ *     based on the ID beeing passed to BTA as user_data.
+ *****************************************************************************/
+
+static void init_sdp_slots() {
+  int i;
+  memset(sdp_slots, 0, sizeof(sdp_slot_t) * MAX_SDP_SLOTS);
+  /* if SDP_RECORD_FREE is zero - no need to set the value */
+  if (SDP_RECORD_FREE != 0) {
+    for (i = 0; i < MAX_SDP_SLOTS; i++) {
+      sdp_slots[i].state = SDP_RECORD_FREE;
+    }
+  }
+}
+
+bt_status_t sdp_server_init() {
+  BTIF_TRACE_DEBUG("Sdp Server %s", __func__);
+  init_sdp_slots();
+  return BT_STATUS_SUCCESS;
+}
+
+void sdp_server_cleanup() {
+  BTIF_TRACE_DEBUG("Sdp Server %s", __func__);
+  std::unique_lock<std::recursive_mutex> lock(sdp_lock);
+  int i;
+  for (i = 0; i < MAX_SDP_SLOTS; i++) {
+    /*remove_sdp_record(i); we cannot send messages to the other threads, since
+    * they might
+    *                       have been shut down already. Just do local cleanup.
+    */
+    free_sdp_slot(i);
+  }
+}
+
+int get_sdp_records_size(bluetooth_sdp_record* in_record, int count) {
+  bluetooth_sdp_record* record = in_record;
+  int records_size = 0;
+  int i;
+  for (i = 0; i < count; i++) {
+    record = &in_record[i];
+    records_size += sizeof(bluetooth_sdp_record);
+    records_size += record->hdr.service_name_length;
+    if (record->hdr.service_name_length > 0) {
+      records_size++; /* + '\0' termination of string */
+    }
+    records_size += record->hdr.user1_ptr_len;
+    records_size += record->hdr.user2_ptr_len;
+  }
+  return records_size;
+}
+
+/* Deep copy all content of in_records into out_records.
+ * out_records must point to a chunk of memory large enough to contain all
+ * the data. Use getSdpRecordsSize() to calculate the needed size. */
+void copy_sdp_records(bluetooth_sdp_record* in_records,
+                      bluetooth_sdp_record* out_records, int count) {
+  int i;
+  bluetooth_sdp_record* in_record;
+  bluetooth_sdp_record* out_record;
+  char* free_ptr =
+      (char*)(&out_records[count]); /* set pointer to after the last entry */
+
+  for (i = 0; i < count; i++) {
+    in_record = &in_records[i];
+    out_record = &out_records[i];
+    *out_record = *in_record;
+
+    if (in_record->hdr.service_name == NULL ||
+        in_record->hdr.service_name_length == 0) {
+      out_record->hdr.service_name = NULL;
+      out_record->hdr.service_name_length = 0;
+    } else {
+      out_record->hdr.service_name = free_ptr;  // Update service_name pointer
+      // Copy string
+      memcpy(free_ptr, in_record->hdr.service_name,
+             in_record->hdr.service_name_length);
+      free_ptr += in_record->hdr.service_name_length;
+      *(free_ptr) = '\0';  // Set '\0' termination of string
+      free_ptr++;
+    }
+    if (in_record->hdr.user1_ptr != NULL) {
+      out_record->hdr.user1_ptr = (uint8_t*)free_ptr;  // Update pointer
+      memcpy(free_ptr, in_record->hdr.user1_ptr,
+             in_record->hdr.user1_ptr_len);  // Copy content
+      free_ptr += in_record->hdr.user1_ptr_len;
+    }
+    if (in_record->hdr.user2_ptr != NULL) {
+      out_record->hdr.user2_ptr = (uint8_t*)free_ptr;  // Update pointer
+      memcpy(free_ptr, in_record->hdr.user2_ptr,
+             in_record->hdr.user2_ptr_len);  // Copy content
+      free_ptr += in_record->hdr.user2_ptr_len;
+    }
+  }
+  return;
+}
+
+/* Reserve a slot in sdp_slots, copy data and set a reference to the copy.
+ * The record_data will contain both the record and any data pointed to by
+ * the record.
+ * Currently this covers:
+ *   service_name string,
+ *   user1_ptr and
+ *   user2_ptr. */
+static int alloc_sdp_slot(bluetooth_sdp_record* in_record) {
+  int record_size = get_sdp_records_size(in_record, 1);
+  /* We are optimists here, and preallocate the record.
+   * This is to reduce the time we hold the sdp_lock. */
+  bluetooth_sdp_record* record = (bluetooth_sdp_record*)osi_malloc(record_size);
+
+  copy_sdp_records(in_record, record, 1);
+  {
+    std::unique_lock<std::recursive_mutex> lock(sdp_lock);
+    for (int i = 0; i < MAX_SDP_SLOTS; i++) {
+      if (sdp_slots[i].state == SDP_RECORD_FREE) {
+        sdp_slots[i].state = SDP_RECORD_ALLOCED;
+        sdp_slots[i].record_data = record;
+        return i;
+      }
+    }
+  }
+  APPL_TRACE_ERROR("%s() failed - no more free slots!", __func__);
+  /* Rearly the optimist is too optimistic, and cleanup is needed...*/
+  osi_free(record);
+  return -1;
+}
+
+static int free_sdp_slot(int id) {
+  int handle = -1;
+  bluetooth_sdp_record* record = NULL;
+  if (id < 0 || id >= MAX_SDP_SLOTS) {
+    android_errorWriteLog(0x534e4554, "37502513");
+    APPL_TRACE_ERROR("%s() failed - id %d is invalid", __func__, id);
+    return handle;
+  }
+
+  {
+    std::unique_lock<std::recursive_mutex> lock(sdp_lock);
+    handle = sdp_slots[id].sdp_handle;
+    sdp_slots[id].sdp_handle = 0;
+    if (sdp_slots[id].state != SDP_RECORD_FREE) {
+      /* safe a copy of the pointer, and free after unlock() */
+      record = sdp_slots[id].record_data;
+    }
+    sdp_slots[id].state = SDP_RECORD_FREE;
+  }
+
+  if (record != NULL) {
+    osi_free(record);
+  } else {
+    // Record have already been freed
+    handle = -1;
+  }
+  return handle;
+}
+
+/***
+ * Use this to get a reference to a SDP slot AND change the state to
+ * SDP_RECORD_CREATE_INITIATED.
+ */
+static const sdp_slot_t* start_create_sdp(int id) {
+  if (id >= MAX_SDP_SLOTS) {
+    APPL_TRACE_ERROR("%s() failed - id %d is invalid", __func__, id);
+    return NULL;
+  }
+
+  std::unique_lock<std::recursive_mutex> lock(sdp_lock);
+  if (sdp_slots[id].state != SDP_RECORD_ALLOCED) {
+    /* The record have been removed before this event occurred - e.g. deinit */
+    APPL_TRACE_ERROR(
+        "%s() failed - state for id %d is "
+        "sdp_slots[id].state = %d expected %d",
+        __func__, id, sdp_slots[id].state, SDP_RECORD_ALLOCED);
+    return NULL;
+  }
+
+  return &(sdp_slots[id]);
+}
+
+static void set_sdp_handle(int id, int handle) {
+  std::unique_lock<std::recursive_mutex> lock(sdp_lock);
+  sdp_slots[id].sdp_handle = handle;
+  BTIF_TRACE_DEBUG("%s() id=%d to handle=0x%08x", __func__, id, handle);
+}
+
+bt_status_t create_sdp_record(bluetooth_sdp_record* record,
+                              int* record_handle) {
+  int handle;
+
+  handle = alloc_sdp_slot(record);
+  BTIF_TRACE_DEBUG("%s() handle = 0x%08x", __func__, handle);
+
+  if (handle < 0) return BT_STATUS_FAIL;
+
+  BTA_SdpCreateRecordByUser(INT_TO_PTR(handle));
+
+  *record_handle = handle;
+
+  return BT_STATUS_SUCCESS;
+}
+
+bt_status_t remove_sdp_record(int record_id) {
+  int handle;
+
+  /* Get the Record handle, and free the slot */
+  handle = free_sdp_slot(record_id);
+  BTIF_TRACE_DEBUG("Sdp Server %s id=%d to handle=0x%08x", __func__, record_id,
+                   handle);
+
+  /* Pass the actual record handle */
+  if (handle > 0) {
+    BTA_SdpRemoveRecordByUser(INT_TO_PTR(handle));
+    return BT_STATUS_SUCCESS;
+  }
+  BTIF_TRACE_DEBUG("Sdp Server %s - record already removed - or never created",
+                   __func__);
+  return BT_STATUS_FAIL;
+}
+
+/******************************************************************************
+ * CALLBACK FUNCTIONS
+ * Called in BTA context to create/remove SDP records.
+ ******************************************************************************/
+
+void on_create_record_event(int id) {
+  /*
+   * 1) Fetch the record pointer, and change its state?
+   * 2) switch on the type to create the correct record
+   * 3) Update state on completion
+   * 4) What to do at fail?
+   * */
+  BTIF_TRACE_DEBUG("Sdp Server %s", __func__);
+  const sdp_slot_t* sdp_slot = start_create_sdp(id);
+  /* In the case we are shutting down, sdp_slot is NULL */
+  if (sdp_slot != NULL) {
+    bluetooth_sdp_record* record = sdp_slot->record_data;
+    int handle = -1;
+    switch (record->hdr.type) {
+      case SDP_TYPE_MAP_MAS:
+        handle = add_maps_sdp(&record->mas);
+        break;
+      case SDP_TYPE_MAP_MNS:
+        handle = add_mapc_sdp(&record->mns);
+        break;
+      case SDP_TYPE_PBAP_PSE:
+        handle = add_pbaps_sdp(&record->pse);
+        break;
+      case SDP_TYPE_OPP_SERVER:
+        handle = add_opps_sdp(&record->ops);
+        break;
+      case SDP_TYPE_SAP_SERVER:
+        handle = add_saps_sdp(&record->sap);
+        break;
+      case SDP_TYPE_PBAP_PCE:
+      //        break; not yet supported
+      default:
+        BTIF_TRACE_DEBUG("Record type %d is not supported", record->hdr.type);
+        break;
+    }
+    if (handle != -1) {
+      set_sdp_handle(id, handle);
+    }
+  }
+}
+
+void on_remove_record_event(int handle) {
+  BTIF_TRACE_DEBUG("Sdp Server %s", __func__);
+
+  // User data carries the actual SDP handle, not the ID.
+  if (handle != -1 && handle != 0) {
+    bool result;
+    result = SDP_DeleteRecord(handle);
+    if (result == false) {
+      BTIF_TRACE_ERROR("  Unable to remove handle 0x%08x", handle);
+    }
+  }
+}
+
+/****
+ * Below the actual functions accessing BTA context data - hence only call from
+ * BTA context!
+ */
+
+/* Create a MAP MAS SDP record based on information stored in a
+ * bluetooth_sdp_mas_record */
+static int add_maps_sdp(const bluetooth_sdp_mas_record* rec) {
+  tSDP_PROTOCOL_ELEM protoList[3];
+  uint16_t service = UUID_SERVCLASS_MESSAGE_ACCESS;
+  uint16_t browse = UUID_SERVCLASS_PUBLIC_BROWSE_GROUP;
+  bool status = true;
+  uint32_t sdp_handle = 0;
+  uint8_t temp[4];
+  uint8_t* p_temp = temp;
+
+  APPL_TRACE_DEBUG(
+      "%s(): MASID = 0x%02x, scn 0x%02x, psm = 0x%04x\n  service name %s",
+      __func__, rec->mas_instance_id, rec->hdr.rfcomm_channel_number,
+      rec->hdr.l2cap_psm, rec->hdr.service_name);
+
+  APPL_TRACE_DEBUG("  msg_types: 0x%02x, feature_bits: 0x%08x",
+                   rec->supported_message_types, rec->supported_features);
+
+  sdp_handle = SDP_CreateRecord();
+  if (sdp_handle == 0) {
+    APPL_TRACE_ERROR("%s() - Unable to register MAPS Service", __func__);
+    return sdp_handle;
+  }
+
+  /* add service class */
+  status &= SDP_AddServiceClassIdList(sdp_handle, 1, &service);
+  memset(protoList, 0, 3 * sizeof(tSDP_PROTOCOL_ELEM));
+
+  /* add protocol list, including RFCOMM scn */
+  protoList[0].protocol_uuid = UUID_PROTOCOL_L2CAP;
+  protoList[0].num_params = 0;
+  protoList[1].protocol_uuid = UUID_PROTOCOL_RFCOMM;
+  protoList[1].num_params = 1;
+  protoList[1].params[0] = rec->hdr.rfcomm_channel_number;
+  protoList[2].protocol_uuid = UUID_PROTOCOL_OBEX;
+  protoList[2].num_params = 0;
+  status &= SDP_AddProtocolList(sdp_handle, 3, protoList);
+
+  /* Add a name entry */
+  status &= SDP_AddAttribute(sdp_handle, (uint16_t)ATTR_ID_SERVICE_NAME,
+                             (uint8_t)TEXT_STR_DESC_TYPE,
+                             (uint32_t)(rec->hdr.service_name_length + 1),
+                             (uint8_t*)rec->hdr.service_name);
+
+  /* Add in the Bluetooth Profile Descriptor List */
+  status &= SDP_AddProfileDescriptorList(sdp_handle, UUID_SERVCLASS_MAP_PROFILE,
+                                         rec->hdr.profile_version);
+
+  /* Add MAS instance ID */
+  status &=
+      SDP_AddAttribute(sdp_handle, ATTR_ID_MAS_INSTANCE_ID, UINT_DESC_TYPE,
+                       (uint32_t)1, (uint8_t*)&rec->mas_instance_id);
+
+  /* Add supported message types */
+  status &=
+      SDP_AddAttribute(sdp_handle, ATTR_ID_SUPPORTED_MSG_TYPE, UINT_DESC_TYPE,
+                       (uint32_t)1, (uint8_t*)&rec->supported_message_types);
+
+  /* Add supported feature */
+  UINT32_TO_BE_STREAM(p_temp, rec->supported_features);
+  status &= SDP_AddAttribute(sdp_handle, ATTR_ID_MAP_SUPPORTED_FEATURES,
+                             UINT_DESC_TYPE, (uint32_t)4, temp);
+
+  /* Add the L2CAP PSM if present */
+  if (rec->hdr.l2cap_psm != -1) {
+    p_temp = temp;  // The macro modifies p_temp, hence rewind.
+    UINT16_TO_BE_STREAM(p_temp, rec->hdr.l2cap_psm);
+    status &= SDP_AddAttribute(sdp_handle, ATTR_ID_GOEP_L2CAP_PSM,
+                               UINT_DESC_TYPE, (uint32_t)2, temp);
+  }
+
+  /* Make the service browseable */
+  status &=
+      SDP_AddUuidSequence(sdp_handle, ATTR_ID_BROWSE_GROUP_LIST, 1, &browse);
+
+  if (!status) {
+    SDP_DeleteRecord(sdp_handle);
+    sdp_handle = 0;
+    APPL_TRACE_ERROR("%s() FAILED", __func__);
+  } else {
+    bta_sys_add_uuid(service); /* UUID_SERVCLASS_MESSAGE_ACCESS */
+    APPL_TRACE_DEBUG("%s():  SDP Registered (handle 0x%08x)", __func__,
+                     sdp_handle);
+  }
+  return sdp_handle;
+}
+
+/* Create a MAP MNS SDP record based on information stored in a
+ * bluetooth_sdp_mns_record */
+static int add_mapc_sdp(const bluetooth_sdp_mns_record* rec) {
+  tSDP_PROTOCOL_ELEM protoList[3];
+  uint16_t service = UUID_SERVCLASS_MESSAGE_NOTIFICATION;
+  uint16_t browse = UUID_SERVCLASS_PUBLIC_BROWSE_GROUP;
+  bool status = true;
+  uint32_t sdp_handle = 0;
+  uint8_t temp[4];
+  uint8_t* p_temp = temp;
+
+  APPL_TRACE_DEBUG("%s(): scn 0x%02x, psm = 0x%04x\n  service name %s",
+                   __func__, rec->hdr.rfcomm_channel_number, rec->hdr.l2cap_psm,
+                   rec->hdr.service_name);
+
+  APPL_TRACE_DEBUG("  feature_bits: 0x%08x", rec->supported_features);
+
+  sdp_handle = SDP_CreateRecord();
+  if (sdp_handle == 0) {
+    APPL_TRACE_ERROR("%s(): Unable to register MAP Notification Service",
+                     __func__);
+    return sdp_handle;
+  }
+
+  /* add service class */
+  status &= SDP_AddServiceClassIdList(sdp_handle, 1, &service);
+  memset(protoList, 0, 3 * sizeof(tSDP_PROTOCOL_ELEM));
+
+  /* add protocol list, including RFCOMM scn */
+  protoList[0].protocol_uuid = UUID_PROTOCOL_L2CAP;
+  protoList[0].num_params = 0;
+  protoList[1].protocol_uuid = UUID_PROTOCOL_RFCOMM;
+  protoList[1].num_params = 1;
+  protoList[1].params[0] = rec->hdr.rfcomm_channel_number;
+  protoList[2].protocol_uuid = UUID_PROTOCOL_OBEX;
+  protoList[2].num_params = 0;
+  status &= SDP_AddProtocolList(sdp_handle, 3, protoList);
+
+  /* Add a name entry */
+  status &= SDP_AddAttribute(sdp_handle, (uint16_t)ATTR_ID_SERVICE_NAME,
+                             (uint8_t)TEXT_STR_DESC_TYPE,
+                             (uint32_t)(rec->hdr.service_name_length + 1),
+                             (uint8_t*)rec->hdr.service_name);
+
+  /* Add in the Bluetooth Profile Descriptor List */
+  status &= SDP_AddProfileDescriptorList(sdp_handle, UUID_SERVCLASS_MAP_PROFILE,
+                                         rec->hdr.profile_version);
+
+  /* Add supported feature */
+  UINT32_TO_BE_STREAM(p_temp, rec->supported_features);
+  status &= SDP_AddAttribute(sdp_handle, ATTR_ID_MAP_SUPPORTED_FEATURES,
+                             UINT_DESC_TYPE, (uint32_t)4, temp);
+
+  /* Add the L2CAP PSM if present */
+  if (rec->hdr.l2cap_psm != -1) {
+    p_temp = temp;  // The macro modifies p_temp, hence rewind.
+    UINT16_TO_BE_STREAM(p_temp, rec->hdr.l2cap_psm);
+    status &= SDP_AddAttribute(sdp_handle, ATTR_ID_GOEP_L2CAP_PSM,
+                               UINT_DESC_TYPE, (uint32_t)2, temp);
+  }
+
+  /* Make the service browseable */
+  status &=
+      SDP_AddUuidSequence(sdp_handle, ATTR_ID_BROWSE_GROUP_LIST, 1, &browse);
+
+  if (!status) {
+    SDP_DeleteRecord(sdp_handle);
+    sdp_handle = 0;
+    APPL_TRACE_ERROR("%s() FAILED", __func__);
+  } else {
+    bta_sys_add_uuid(service); /* UUID_SERVCLASS_MESSAGE_ACCESS */
+    APPL_TRACE_DEBUG("%s():  SDP Registered (handle 0x%08x)", __func__,
+                     sdp_handle);
+  }
+  return sdp_handle;
+}
+
+/* Create a PBAP Server SDP record based on information stored in a
+ * bluetooth_sdp_pse_record */
+static int add_pbaps_sdp(const bluetooth_sdp_pse_record* rec) {
+  tSDP_PROTOCOL_ELEM protoList[3];
+  uint16_t service = UUID_SERVCLASS_PBAP_PSE;
+  uint16_t browse = UUID_SERVCLASS_PUBLIC_BROWSE_GROUP;
+  bool status = true;
+  uint32_t sdp_handle = 0;
+  uint8_t temp[4];
+  uint8_t* p_temp = temp;
+
+  APPL_TRACE_DEBUG("%s(): scn 0x%02x, psm = 0x%04x\n  service name %s",
+                   __func__, rec->hdr.rfcomm_channel_number, rec->hdr.l2cap_psm,
+                   rec->hdr.service_name);
+
+  APPL_TRACE_DEBUG("  supported_repositories: 0x%08x, feature_bits: 0x%08x",
+                   rec->supported_repositories, rec->supported_features);
+
+  sdp_handle = SDP_CreateRecord();
+  if (sdp_handle == 0) {
+    APPL_TRACE_ERROR("%s(): Unable to register PBAP Server Service", __func__);
+    return sdp_handle;
+  }
+
+  /* add service class */
+  status &= SDP_AddServiceClassIdList(sdp_handle, 1, &service);
+  memset(protoList, 0, 3 * sizeof(tSDP_PROTOCOL_ELEM));
+
+  /* add protocol list, including RFCOMM scn */
+  protoList[0].protocol_uuid = UUID_PROTOCOL_L2CAP;
+  protoList[0].num_params = 0;
+  protoList[1].protocol_uuid = UUID_PROTOCOL_RFCOMM;
+  protoList[1].num_params = 1;
+  protoList[1].params[0] = rec->hdr.rfcomm_channel_number;
+  protoList[2].protocol_uuid = UUID_PROTOCOL_OBEX;
+  protoList[2].num_params = 0;
+  status &= SDP_AddProtocolList(sdp_handle, 3, protoList);
+
+  /* Add a name entry */
+  status &= SDP_AddAttribute(sdp_handle, (uint16_t)ATTR_ID_SERVICE_NAME,
+                             (uint8_t)TEXT_STR_DESC_TYPE,
+                             (uint32_t)(rec->hdr.service_name_length + 1),
+                             (uint8_t*)rec->hdr.service_name);
+
+  /* Add in the Bluetooth Profile Descriptor List */
+  status &= SDP_AddProfileDescriptorList(
+      sdp_handle, UUID_SERVCLASS_PHONE_ACCESS, rec->hdr.profile_version);
+
+  /* Add supported repositories 1 byte */
+  status &= SDP_AddAttribute(sdp_handle, ATTR_ID_SUPPORTED_REPOSITORIES,
+                             UINT_DESC_TYPE, (uint32_t)1,
+                             (uint8_t*)&rec->supported_repositories);
+
+  /* Add supported feature 4 bytes*/
+  UINT32_TO_BE_STREAM(p_temp, rec->supported_features);
+  status &= SDP_AddAttribute(sdp_handle, ATTR_ID_PBAP_SUPPORTED_FEATURES,
+                             UINT_DESC_TYPE, (uint32_t)4, temp);
+
+  /* Add the L2CAP PSM if present */
+  if (rec->hdr.l2cap_psm != -1) {
+    p_temp = temp;  // The macro modifies p_temp, hence rewind.
+    UINT16_TO_BE_STREAM(p_temp, rec->hdr.l2cap_psm);
+    status &= SDP_AddAttribute(sdp_handle, ATTR_ID_GOEP_L2CAP_PSM,
+                               UINT_DESC_TYPE, (uint32_t)2, temp);
+  }
+
+  /* Make the service browseable */
+  status &=
+      SDP_AddUuidSequence(sdp_handle, ATTR_ID_BROWSE_GROUP_LIST, 1, &browse);
+
+  if (!status) {
+    SDP_DeleteRecord(sdp_handle);
+    sdp_handle = 0;
+    APPL_TRACE_ERROR("%s() FAILED", __func__);
+  } else {
+    bta_sys_add_uuid(service); /* UUID_SERVCLASS_MESSAGE_ACCESS */
+    APPL_TRACE_DEBUG("%s():  SDP Registered (handle 0x%08x)", __func__,
+                     sdp_handle);
+  }
+  return sdp_handle;
+}
+
+/* Create a OPP Server SDP record based on information stored in a
+ * bluetooth_sdp_ops_record */
+static int add_opps_sdp(const bluetooth_sdp_ops_record* rec) {
+  tSDP_PROTOCOL_ELEM protoList[3];
+  uint16_t service = UUID_SERVCLASS_OBEX_OBJECT_PUSH;
+  uint16_t browse = UUID_SERVCLASS_PUBLIC_BROWSE_GROUP;
+  uint8_t type_len[rec->supported_formats_list_len];
+  uint8_t desc_type[rec->supported_formats_list_len];
+  uint8_t* type_value[rec->supported_formats_list_len];
+  bool status = true;
+  uint32_t sdp_handle = 0;
+  uint8_t temp[4];
+  uint8_t* p_temp = temp;
+  tBTA_UTL_COD cod;
+  int i, j;
+
+  APPL_TRACE_DEBUG("%s(): scn 0x%02x, psm = 0x%04x\n  service name %s",
+                   __func__, rec->hdr.rfcomm_channel_number, rec->hdr.l2cap_psm,
+                   rec->hdr.service_name);
+
+  APPL_TRACE_DEBUG("  supported formats count: %d",
+                   rec->supported_formats_list_len);
+
+  sdp_handle = SDP_CreateRecord();
+  if (sdp_handle == 0) {
+    APPL_TRACE_ERROR("%s(): Unable to register Object Push Server Service",
+                     __func__);
+    return sdp_handle;
+  }
+
+  /* add service class */
+  status &= SDP_AddServiceClassIdList(sdp_handle, 1, &service);
+  memset(protoList, 0, 3 * sizeof(tSDP_PROTOCOL_ELEM));
+
+  /* add protocol list, including RFCOMM scn */
+  protoList[0].protocol_uuid = UUID_PROTOCOL_L2CAP;
+  protoList[0].num_params = 0;
+  protoList[1].protocol_uuid = UUID_PROTOCOL_RFCOMM;
+  protoList[1].num_params = 1;
+  protoList[1].params[0] = rec->hdr.rfcomm_channel_number;
+  protoList[2].protocol_uuid = UUID_PROTOCOL_OBEX;
+  protoList[2].num_params = 0;
+  status &= SDP_AddProtocolList(sdp_handle, 3, protoList);
+
+  /* Add a name entry */
+  status &= SDP_AddAttribute(sdp_handle, (uint16_t)ATTR_ID_SERVICE_NAME,
+                             (uint8_t)TEXT_STR_DESC_TYPE,
+                             (uint32_t)(rec->hdr.service_name_length + 1),
+                             (uint8_t*)rec->hdr.service_name);
+
+  /* Add in the Bluetooth Profile Descriptor List */
+  status &= SDP_AddProfileDescriptorList(
+      sdp_handle, UUID_SERVCLASS_OBEX_OBJECT_PUSH, rec->hdr.profile_version);
+
+  /* add sequence for supported types */
+  for (i = 0, j = 0; i < rec->supported_formats_list_len; i++) {
+    type_value[j] = (uint8_t*)&rec->supported_formats_list[i];
+    desc_type[j] = UINT_DESC_TYPE;
+    type_len[j++] = 1;
+  }
+
+  status &=
+      SDP_AddSequence(sdp_handle, (uint16_t)ATTR_ID_SUPPORTED_FORMATS_LIST,
+                      (uint8_t)rec->supported_formats_list_len, desc_type,
+                      type_len, type_value);
+
+  /* Add the L2CAP PSM if present */
+  if (rec->hdr.l2cap_psm != -1) {
+    p_temp = temp;  // The macro modifies p_temp, hence rewind.
+    UINT16_TO_BE_STREAM(p_temp, rec->hdr.l2cap_psm);
+    status &= SDP_AddAttribute(sdp_handle, ATTR_ID_GOEP_L2CAP_PSM,
+                               UINT_DESC_TYPE, (uint32_t)2, temp);
+  }
+
+  /* Make the service browseable */
+  status &=
+      SDP_AddUuidSequence(sdp_handle, ATTR_ID_BROWSE_GROUP_LIST, 1, &browse);
+
+  if (!status) {
+    SDP_DeleteRecord(sdp_handle);
+    sdp_handle = 0;
+    APPL_TRACE_ERROR("%s() FAILED", __func__);
+  } else {
+    /* set class of device */
+    cod.service = BTM_COD_SERVICE_OBJ_TRANSFER;
+    utl_set_device_class(&cod, BTA_UTL_SET_COD_SERVICE_CLASS);
+
+    bta_sys_add_uuid(service); /* UUID_SERVCLASS_OBEX_OBJECT_PUSH */
+    APPL_TRACE_DEBUG("%s():  SDP Registered (handle 0x%08x)", __func__,
+                     sdp_handle);
+  }
+  return sdp_handle;
+}
+
+// Create a Sim Access Profile SDP record based on information stored in a
+// bluetooth_sdp_sap_record.
+static int add_saps_sdp(const bluetooth_sdp_sap_record* rec) {
+  tSDP_PROTOCOL_ELEM protoList[2];
+  uint16_t services[2];
+  uint16_t browse = UUID_SERVCLASS_PUBLIC_BROWSE_GROUP;
+  bool status = true;
+  uint32_t sdp_handle = 0;
+
+  APPL_TRACE_DEBUG("%s(): scn 0x%02x, service name %s", __func__,
+                   rec->hdr.rfcomm_channel_number, rec->hdr.service_name);
+
+  sdp_handle = SDP_CreateRecord();
+  if (sdp_handle == 0) {
+    APPL_TRACE_ERROR("%s(): Unable to register SAPS Service", __func__);
+    return sdp_handle;
+  }
+
+  services[0] = UUID_SERVCLASS_SAP;
+  services[1] = UUID_SERVCLASS_GENERIC_TELEPHONY;
+
+  // add service class
+  status &= SDP_AddServiceClassIdList(sdp_handle, 2, services);
+  memset(protoList, 0, 2 * sizeof(tSDP_PROTOCOL_ELEM));
+
+  // add protocol list, including RFCOMM scn
+  protoList[0].protocol_uuid = UUID_PROTOCOL_L2CAP;
+  protoList[0].num_params = 0;
+  protoList[1].protocol_uuid = UUID_PROTOCOL_RFCOMM;
+  protoList[1].num_params = 1;
+  protoList[1].params[0] = rec->hdr.rfcomm_channel_number;
+  status &= SDP_AddProtocolList(sdp_handle, 2, protoList);
+
+  // Add a name entry
+  status &= SDP_AddAttribute(sdp_handle, (uint16_t)ATTR_ID_SERVICE_NAME,
+                             (uint8_t)TEXT_STR_DESC_TYPE,
+                             (uint32_t)(rec->hdr.service_name_length + 1),
+                             (uint8_t*)rec->hdr.service_name);
+
+  // Add in the Bluetooth Profile Descriptor List
+  status &= SDP_AddProfileDescriptorList(sdp_handle, UUID_SERVCLASS_SAP,
+                                         rec->hdr.profile_version);
+
+  // Make the service browseable
+  status &=
+      SDP_AddUuidSequence(sdp_handle, ATTR_ID_BROWSE_GROUP_LIST, 1, &browse);
+
+  if (!status) {
+    SDP_DeleteRecord(sdp_handle);
+    sdp_handle = 0;
+    APPL_TRACE_ERROR("%s(): FAILED deleting record", __func__);
+  } else {
+    bta_sys_add_uuid(UUID_SERVCLASS_SAP);
+    APPL_TRACE_DEBUG("%s(): SDP Registered (handle 0x%08x)", __func__,
+                     sdp_handle);
+  }
+  return sdp_handle;
+}
diff --git a/stack/avdt/avdt_api.c b/stack/avdt/avdt_api.c
index 98ef5f7..258f424 100644
--- a/stack/avdt/avdt_api.c
+++ b/stack/avdt/avdt_api.c
@@ -1208,7 +1208,7 @@ UINT16 AVDT_SendReport(UINT8 handle, AVDT_REPORT_TYPE type,
         /* build SR - assume fit in one packet */
         p_tbl = avdt_ad_tc_tbl_by_type(AVDT_CHAN_REPORT, p_scb->p_ccb, p_scb);
         if (p_tbl->state == AVDT_AD_ST_OPEN) {
-            BT_HDR *p_pkt = (BT_HDR *)osi_malloc(p_tbl->peer_mtu);
+            BT_HDR* p_pkt = (BT_HDR*)osi_malloc(p_tbl->peer_mtu + sizeof(BT_HDR));
 
             p_pkt->offset = L2CAP_MIN_OFFSET;
             p = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
diff --git a/stack/bnep/bnep_main.c b/stack/bnep/bnep_main.c
index 078a72e..9b01472 100644
--- a/stack/bnep/bnep_main.c
+++ b/stack/bnep/bnep_main.c
@@ -575,7 +575,8 @@ static void bnep_data_ind (UINT16 l2cap_cid, BT_HDR *p_buf)
             p_bcb->con_state != BNEP_STATE_CONNECTED &&
             extension_present && p && rem_len)
         {
-            p_bcb->p_pending_data = (BT_HDR *)osi_malloc(rem_len);
+            osi_free(p_bcb->p_pending_data);
+            p_bcb->p_pending_data = (BT_HDR*)osi_malloc(rem_len + sizeof(BT_HDR));
             memcpy((UINT8 *)(p_bcb->p_pending_data + 1), p, rem_len);
             p_bcb->p_pending_data->len    = rem_len;
             p_bcb->p_pending_data->offset = 0;
diff --git a/stack/bnep/bnep_utils.c b/stack/bnep/bnep_utils.c
index 13fb189..2250634 100644
--- a/stack/bnep/bnep_utils.c
+++ b/stack/bnep/bnep_utils.c
@@ -154,7 +154,7 @@ void bnepu_release_bcb (tBNEP_CONN *p_bcb)
 
     /* Drop any response pointer we may be holding */
     p_bcb->con_state        = BNEP_STATE_IDLE;
-    p_bcb->p_pending_data   = NULL;
+    osi_free_and_reset((void**)&p_bcb->p_pending_data);
 
     /* Free transmit queue */
     while (!fixed_queue_is_empty(p_bcb->xmit_q))
@@ -762,24 +762,43 @@ void bnep_process_setup_conn_responce (tBNEP_CONN *p_bcb, UINT8 *p_setup)
 UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len, BOOLEAN is_ext)
 {
     UINT8       control_type;
-    BOOLEAN     bad_pkt = FALSE;
     UINT16      len, ext_len = 0;
 
+    if (p == NULL || rem_len == NULL) {
+       if (rem_len != NULL) *rem_len = 0;
+       BNEP_TRACE_DEBUG("%s: invalid packet: p = %p rem_len = %p", __func__, p,
+                        rem_len);
+       return NULL;
+    }
+    UINT16 rem_len_orig = *rem_len;
+
     if (is_ext)
     {
+        if (*rem_len < 1) goto bad_packet_length;
         ext_len = *p++;
         *rem_len = *rem_len - 1;
     }
 
+    if (*rem_len < 1) goto bad_packet_length;
     control_type = *p++;
     *rem_len = *rem_len - 1;
 
-    BNEP_TRACE_EVENT ("BNEP processing control packet rem_len %d, is_ext %d, ctrl_type %d", *rem_len, is_ext, control_type);
+    BNEP_TRACE_EVENT (
+       "%s: BNEP processing control packet rem_len %d, is_ext %d, ctrl_type %d",
+       __func__, *rem_len, is_ext, control_type);
 
     switch (control_type)
     {
     case BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD:
-        BNEP_TRACE_ERROR ("BNEP Received Cmd not understood for ctl pkt type: %d", *p);
+       if (*rem_len < 1) {
+         BNEP_TRACE_ERROR(
+             "%s: Received BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD with bad length",
+             __func__);
+         goto bad_packet_length;
+       }
+       BNEP_TRACE_ERROR(
+           "%s: Received BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD for pkt type: %d",
+           __func__, *p);
         p++;
         *rem_len = *rem_len - 1;
         break;
@@ -788,9 +807,10 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         len = *p++;
         if (*rem_len < ((2 * len) + 1))
         {
-            bad_pkt = TRUE;
-            BNEP_TRACE_ERROR ("BNEP Received Setup message with bad length");
-            break;
+            BNEP_TRACE_ERROR(
+                "%s: Received BNEP_SETUP_CONNECTION_REQUEST_MSG with bad length",
+                __func__);
+            goto bad_packet_length;
         }
         if (!is_ext)
             bnep_process_setup_conn_req (p_bcb, p, (UINT8)len);
@@ -799,6 +819,12 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         break;
 
     case BNEP_SETUP_CONNECTION_RESPONSE_MSG:
+        if (*rem_len < 2) {
+          BNEP_TRACE_ERROR(
+              "%s: Received BNEP_SETUP_CONNECTION_RESPONSE_MSG with bad length",
+              __func__);
+          goto bad_packet_length;
+        }
         if (!is_ext)
             bnep_process_setup_conn_responce (p_bcb, p);
         p += 2;
@@ -809,9 +835,10 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         BE_STREAM_TO_UINT16 (len, p);
         if (*rem_len < (len + 2))
         {
-            bad_pkt = TRUE;
-            BNEP_TRACE_ERROR ("BNEP Received Filter set message with bad length");
-            break;
+           BNEP_TRACE_ERROR(
+               "%s: Received BNEP_FILTER_NET_TYPE_SET_MSG with bad length",
+               __func__);
+           goto bad_packet_length;
         }
         bnepu_process_peer_filter_set (p_bcb, p, len);
         p += len;
@@ -819,6 +846,12 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         break;
 
     case BNEP_FILTER_NET_TYPE_RESPONSE_MSG:
+        if (*rem_len < 2) {
+          BNEP_TRACE_ERROR(
+              "%s: Received BNEP_FILTER_NET_TYPE_RESPONSE_MSG with bad length",
+              __func__);
+          goto bad_packet_length;
+        }
         bnepu_process_peer_filter_rsp (p_bcb, p);
         p += 2;
         *rem_len = *rem_len - 2;
@@ -828,9 +861,10 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         BE_STREAM_TO_UINT16 (len, p);
         if (*rem_len < (len + 2))
         {
-            bad_pkt = TRUE;
-            BNEP_TRACE_ERROR ("BNEP Received Multicast Filter Set message with bad length");
-            break;
+           BNEP_TRACE_ERROR (
+               "%s: Received BNEP_FILTER_MULTI_ADDR_SET_MSG with bad length",
+               __func__);
+           goto bad_packet_length;
         }
         bnepu_process_peer_multicast_filter_set (p_bcb, p, len);
         p += len;
@@ -838,30 +872,38 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         break;
 
     case BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG:
+        if (*rem_len < 2) {
+          BNEP_TRACE_ERROR(
+              "%s: Received BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG with bad length",
+              __func__);
+          goto bad_packet_length;
+        }
         bnepu_process_multicast_filter_rsp (p_bcb, p);
         p += 2;
         *rem_len = *rem_len - 2;
         break;
 
     default :
-        BNEP_TRACE_ERROR ("BNEP - bad ctl pkt type: %d", control_type);
+        BNEP_TRACE_ERROR("%s: BNEP - bad ctl pkt type: %d", __func__,
+                         control_type);
         bnep_send_command_not_understood (p_bcb, control_type);
-        if (is_ext)
-        {
+        if (is_ext && (ext_len > 0)) {
+            if (*rem_len < (ext_len - 1)) {
+               goto bad_packet_length;
+            }
             p += (ext_len - 1);
             *rem_len -= (ext_len - 1);
         }
         break;
     }
 
-    if (bad_pkt)
-    {
-        BNEP_TRACE_ERROR ("BNEP - bad ctl pkt length: %d", *rem_len);
-        *rem_len = 0;
-        return NULL;
-    }
-
     return p;
+
+bad_packet_length:
+  BNEP_TRACE_ERROR("%s: bad control packet length: original=%d remaining=%d",
+                   __func__, rem_len_orig, *rem_len);
+  *rem_len = 0;
+  return NULL;
 }
 
 
diff --git a/stack/l2cap/l2cap_client.c b/stack/l2cap/l2cap_client.c
index 7e8b3cb..ce58cdc 100644
--- a/stack/l2cap/l2cap_client.c
+++ b/stack/l2cap/l2cap_client.c
@@ -370,7 +370,7 @@ static void fragment_packet(l2cap_client_t *client, buffer_t *packet) {
   assert(packet != NULL);
 
   // TODO(sharvil): eliminate copy into BT_HDR.
-  BT_HDR *bt_packet = osi_malloc(buffer_length(packet) + L2CAP_MIN_OFFSET);
+  BT_HDR *bt_packet = osi_malloc(buffer_length(packet) + L2CAP_MIN_OFFSET + sizeof(BT_HDR));
   bt_packet->offset = L2CAP_MIN_OFFSET;
   bt_packet->len = buffer_length(packet);
   memcpy(bt_packet->data + bt_packet->offset, buffer_ptr(packet), buffer_length(packet));
@@ -384,7 +384,7 @@ static void fragment_packet(l2cap_client_t *client, buffer_t *packet) {
       break;
     }
 
-    BT_HDR *fragment = osi_malloc(client->remote_mtu + L2CAP_MIN_OFFSET);
+    BT_HDR *fragment = osi_malloc(client->remote_mtu + L2CAP_MIN_OFFSET + sizeof(BT_HDR));
     fragment->offset = L2CAP_MIN_OFFSET;
     fragment->len = client->remote_mtu;
     memcpy(fragment->data + fragment->offset, bt_packet->data + bt_packet->offset, client->remote_mtu);
diff --git a/stack/mcap/mca_cact.c b/stack/mcap/mca_cact.c
index 583a342..6694ff7 100644
--- a/stack/mcap/mca_cact.c
+++ b/stack/mcap/mca_cact.c
@@ -122,7 +122,7 @@ void mca_ccb_snd_req(tMCA_CCB *p_ccb, tMCA_CCB_EVT *p_data)
         p_ccb->p_tx_req = p_msg;
         if (!p_ccb->cong)
         {
-            BT_HDR *p_pkt = (BT_HDR *)osi_malloc(MCA_CTRL_MTU);
+            BT_HDR *p_pkt = (BT_HDR *)osi_malloc(MCA_CTRL_MTU + sizeof(BT_HDR));
 
             p_pkt->offset = L2CAP_MIN_OFFSET;
             p = p_start = (UINT8*)(p_pkt + 1) + L2CAP_MIN_OFFSET;
@@ -164,7 +164,7 @@ void mca_ccb_snd_rsp(tMCA_CCB *p_ccb, tMCA_CCB_EVT *p_data)
     tMCA_CCB_MSG *p_msg = (tMCA_CCB_MSG *)p_data;
     UINT8   *p, *p_start;
     BOOLEAN chk_mdl = FALSE;
-    BT_HDR *p_pkt = (BT_HDR *)osi_malloc(MCA_CTRL_MTU);
+    BT_HDR *p_pkt = (BT_HDR *)osi_malloc(MCA_CTRL_MTU + sizeof(BT_HDR));
 
     MCA_TRACE_DEBUG("%s cong=%d req=%d", __func__, p_ccb->cong, p_msg->op_code);
     /* assume that API functions verified the parameters */
@@ -404,7 +404,7 @@ void mca_ccb_hdl_req(tMCA_CCB *p_ccb, tMCA_CCB_EVT *p_data)
 
     if (((reject_code != MCA_RSP_SUCCESS) && (evt_data.hdr.op_code != MCA_OP_SYNC_INFO_IND))
         || send_rsp) {
-        BT_HDR *p_buf = (BT_HDR *)osi_malloc(MCA_CTRL_MTU);
+        BT_HDR *p_buf = (BT_HDR *)osi_malloc(MCA_CTRL_MTU + sizeof(BT_HDR));
         p_buf->offset = L2CAP_MIN_OFFSET;
         p = p_start = (UINT8*)(p_buf + 1) + L2CAP_MIN_OFFSET;
         *p++ = reject_opcode;
diff --git a/stack/pan/pan_main.c b/stack/pan/pan_main.c
index 5c3a367..044469d 100644
--- a/stack/pan/pan_main.c
+++ b/stack/pan/pan_main.c
@@ -221,6 +221,38 @@ void pan_conn_ind_cb (UINT16 handle,
         BNEP_ConnectResp (handle, BNEP_CONN_FAILED_DST_UUID);
         return;
     }
+    /* Check for valid interactions between the three PAN profile roles */
+    /*
+     * For reference, see Table 1 in PAN Profile v1.0 spec.
+     * Note: the remote is the initiator.
+     */
+    bool is_valid_interaction = false;
+    switch (remote_uuid->uu.uuid16) {
+      case UUID_SERVCLASS_NAP:
+      case UUID_SERVCLASS_GN:
+         if (local_uuid->uu.uuid16 == UUID_SERVCLASS_PANU)
+          is_valid_interaction = true;
+        break;
+      case UUID_SERVCLASS_PANU:
+        is_valid_interaction = true;
+        break;
+    }
+    /*
+     * Explicitly disable connections to the local PANU if the remote is
+     * not PANU.
+     */
+    if ((local_uuid->uu.uuid16 == UUID_SERVCLASS_PANU) &&
+        (remote_uuid->uu.uuid16 != UUID_SERVCLASS_PANU)) {
+      is_valid_interaction = false;
+    }
+    if (!is_valid_interaction) {
+      PAN_TRACE_ERROR(
+          "PAN Connection failed because of invalid PAN profile roles "
+          "interaction: Remote UUID 0x%x Local UUID 0x%x",
+          remote_uuid->uu.uuid16, local_uuid->uu.uuid16);
+      BNEP_ConnectResp(handle, BNEP_CONN_FAILED_SRC_UUID);
+      return;
+    }
 
     /* Requested destination role is */
     if (local_uuid->uu.uuid16 == UUID_SERVCLASS_PANU)
diff --git a/stack/sdp/sdp_server.c b/stack/sdp/sdp_server.c
index 627f4cf..5b0bde4 100644
--- a/stack/sdp/sdp_server.c
+++ b/stack/sdp/sdp_server.c
@@ -230,7 +230,7 @@ static void process_service_search (tCONN_CB *p_ccb, UINT16 trans_num,
         }
         BE_STREAM_TO_UINT16 (cont_offset, p_req);
 
-        if (cont_offset != p_ccb->cont_offset)
+        if (cont_offset != p_ccb->cont_offset || num_rsp_handles < cont_offset)
         {
             sdpu_build_n_send_error (p_ccb, trans_num, SDP_INVALID_CONT_STATE,
                                      SDP_TEXT_BAD_CONT_INX);
